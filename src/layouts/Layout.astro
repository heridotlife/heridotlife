---
import '../styles/globals.css';
import { siteConfig } from '../consts';
import { getSafeCanonicalUrl } from '../lib/security';

export interface Props {
  title: string;
  description?: string;
  ogType?: 'default' | 'category' | 'url';
  ogCategory?: string;
  ogClicks?: string;
  ogImage?: string;
  originalUrl?: string;
}

const {
  title,
  description = siteConfig.description,
  ogType = 'default',
  ogCategory,
  ogClicks,
  ogImage,
  originalUrl,
} = Astro.props;

// Generate safe canonical URL using validated host
const canonicalUrl = getSafeCanonicalUrl(
  Astro.request,
  Astro.url.pathname,
  Astro.locals?.runtime?.env
);

// Generate dynamic OG image URL
const ogImageUrl =
  ogImage ||
  (() => {
    const params = new URLSearchParams();
    params.set('title', title);
    params.set('description', description);
    params.set('type', ogType);

    if (ogCategory) params.set('category', ogCategory);
    if (ogClicks) params.set('clicks', ogClicks);
    if (originalUrl) params.set('originalUrl', originalUrl);

    return `${siteConfig.url}/api/og?${params.toString()}`;
  })();
---

<!doctype html>
<html lang="en" class="">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <meta name="description" content={description} />
    <link rel="canonical" href={canonicalUrl} />
    <link rel="author" href="https://heri.life" />
    <meta name="author" content="Heri Rusmanto" />
    <link rel="manifest" href="/favicon/site.webmanifest" />
    <meta name="robots" content="index, follow" />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalUrl} />
    <meta property="og:site_name" content={siteConfig.title} />
    <meta property="og:locale" content="en_US" />
    <meta property="og:image" content={ogImageUrl} />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:creator" content="@heridotlife" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={ogImageUrl} />
    <link rel="shortcut icon" href="/favicon/favicon-16x16.png" />
    <link rel="icon" href="/favicon/favicon.ico" />
    <link rel="apple-touch-icon" href="/favicon/apple-touch-icon.png" />

    <!-- Resource Hints for Performance Optimization -->
    <!-- DNS prefetch for external domains -->
    <link rel="dns-prefetch" href="https://cloudflare.com" />

    <!-- Preconnect for critical external resources -->
    <link rel="preconnect" href="https://cloudflareinsights.com" crossorigin />

    <!-- Preload critical images for LCP optimization -->
    <link rel="preload" as="image" href="/profile_picture.jpg" fetchpriority="high" />

    <!-- Critical CSS: Inline above-the-fold styles for instant rendering -->
    <style>
      /* Critical base styles - Immediate render */
      *,
      ::before,
      ::after {
        box-sizing: border-box;
        border-width: 0;
        border-style: solid;
      }

      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        tab-size: 4;
      }

      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        line-height: inherit;
        font-display: swap;
      }

      /* Prevent layout shift during font load */
      @font-face {
        font-family: 'Fallback Font';
        font-display: swap;
      }

      /* Critical loading states */
      .loading {
        opacity: 0;
        transition: opacity 0.2s ease-in;
      }

      .loaded {
        opacity: 1;
      }

      /* Prevent FOUC (Flash of Unstyled Content) */
      html:not(.loaded) body {
        visibility: hidden;
      }

      html.loaded body {
        visibility: visible;
      }
    </style>

    <!-- Mark HTML as loaded immediately -->
    <script is:inline>
      document.documentElement.classList.add('loaded');
    </script>

    <script is:inline>
      (function () {
        const savedTheme = localStorage.getItem('theme');
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const shouldBeDark = savedTheme ? savedTheme === 'dark' : systemPrefersDark;
        if (shouldBeDark) {
          document.documentElement.classList.add('dark');
        }
      })();
    </script>

    <!-- Cloudflare Analytics and Performance Monitoring -->
    <script is:inline>
      // Simple Core Web Vitals tracking for Cloudflare
      function sendToAnalytics(metric) {
        // Log to console in development
        if (typeof console !== 'undefined') {
          console.log('[Performance]', metric.name, metric.value, metric);
        }

        // Send to Cloudflare Analytics endpoint
        if (navigator.sendBeacon && window.location.hostname !== 'localhost') {
          const data = {
            metric: metric.name,
            value: metric.value,
            id: metric.id,
            timestamp: Date.now(),
            url: window.location.href,
          };
          navigator.sendBeacon('/api/analytics/vitals', JSON.stringify(data));
        }
      }

      // Basic performance observation without external dependencies
      if ('PerformanceObserver' in window) {
        // Largest Contentful Paint (LCP)
        try {
          const lcpObserver = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.entryType === 'largest-contentful-paint') {
                sendToAnalytics({
                  name: 'LCP',
                  value: entry.startTime,
                  id: crypto.randomUUID?.() || Math.random().toString(36),
                });
              }
            }
          });
          lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });
        } catch {
          // Performance API not available
        }

        // First Contentful Paint (FCP) and Navigation Timing
        try {
          const observer = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
              if (entry.name === 'first-contentful-paint') {
                sendToAnalytics({
                  name: 'FCP',
                  value: entry.startTime,
                  id: crypto.randomUUID?.() || Math.random().toString(36),
                });
              }
            }
          });
          observer.observe({ type: 'paint', buffered: true });
        } catch {
          // Performance API not available
        }
      }

      // Time to First Byte (TTFB) using Navigation Timing
      window.addEventListener('load', () => {
        if ('performance' in window && 'getEntriesByType' in performance) {
          const navEntry = performance.getEntriesByType('navigation')[0];
          if (navEntry) {
            sendToAnalytics({
              name: 'TTFB',
              value: navEntry.responseStart - navEntry.requestStart,
              id: crypto.randomUUID?.() || Math.random().toString(36),
            });
          }
        }
      });
    </script>

    <!-- Service Worker Registration for Offline Support -->
    <script is:inline>
      // Register service worker for offline support and caching
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker
            .register('/sw.js')
            .then((registration) => {
              console.log('[SW] Service Worker registered:', registration.scope);

              // Check for updates periodically
              setInterval(
                () => {
                  registration.update();
                },
                60 * 60 * 1000
              ); // Check every hour
            })
            .catch((error) => {
              console.error('[SW] Service Worker registration failed:', error);
            });

          // Handle service worker updates
          let refreshing = false;
          navigator.serviceWorker.addEventListener('controllerchange', () => {
            if (!refreshing) {
              refreshing = true;
              window.location.reload();
            }
          });
        });
      }
    </script>
  </head>
  <body>
    <slot />
  </body>
</html>
